<!DOCTYPE html>
<!--
Copyright (c) 2017, integrality.life
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this
  list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice,
  this list of conditions and the following disclaimer in the documentation
  and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
    <head>
        <meta charset="UTF-8"/>
        <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
        <meta name="viewport" content="width-device-width, initial-scale=1"/>
        <title>JS Cheat Sheet | Integrality Life</title>
        <meta name="author" content="integrality.life"/>
        <meta name="description" content="JavaScript Programming Cheat Sheet."/>

        <base target="_self"/>
        <link rel="stylesheet" href="assets/integralitylife/css/bootstrap-grid.min.css"/>
        <link rel="stylesheet" href="assets/integralitylife/css/main.min.css"/>
        <link rel="stylesheet" href="assets/integralitylife/css/idea.min.css"/>
        <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
        <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
        <![endif]-->
        <script src="assets/integralitylife/js/libs.min.js"></script>
        <script defer src="assets/integralitylife/js/common.js"></script>
    </head>
    <body>
        <header>
            <div class="container">
                <div class="row">
                    <!-- Content -->
                    <div class="col-sm-12 col-md-12 col-lg-12">
                        <nav class="main-menu">
                            <h1>JavaScript Cheat Sheet!</h1>
                        </nav>
                    </div>
                </div>
            </div>
        </header>
        <main>
            <div class="container">
                <div class="row">
                    <article class="col-sm-12 col-md-8 col-lg-9">
                        <!-- Content -->
                        <figure class="block-quote">
                            <blockquote>
                                JavaScript (он же JS, Яваскрипт, LiveScript, ECMAScript, Жабаскрипт) — поделие Брендана
                                Айха, чуть более чем повсеместно использующееся для написания костылей к тому, что не
                                сделать с помощью HTML и CSS. Если где-либо на веб-странице что-либо выдвигается,
                                скукоживается, моргает, перекрашивается, перекашивается, вырвиглазно всплывает, икает,
                                гыгыкает, хрюкает, пукает и весело ржот за кадром — и всё это при отсутствии Flash или
                                CSS, — это и есть JavaScript.
                            </blockquote>
                            <figcaption>Материал с Lurkmore</figcaption>
                        </figure>
                        <section>
                            <a id="ch01"></a>
                            <h2>Начинаем</h2>
                            <p>
                                Изначально JavaScript использовался в браузерах, но со временем это изменилось и уже ни
                                у кого нет сомнений, что это &quot;полноценный&quot; язык. С его помощью можно достичь
                                всего того, чего можно достичь с другими &quot;полноценными&quot; языками.
                            </p>
                            <p>
                                Вне браузера скрипты, написанные на JavaScript можно запускать с помощью
                                <dfn>Node.js</dfn>. Чтобы Ваш код был выполнен вне браузера он должен быть
                                интерпретирован и выполнен. Именно это и делает Node.js с помощью движка
                                <dfn>v8 VM</dfn>, разработанного Google. Этот же движок использует
                                браузер <dfn>Google Chrome</dfn>.
                            </p>
                            <p>
                                Поскольку код JavaScript это обычный текст, то писать его можно как в текстовых
                                редакторах, которые могут сохранять файлы в форрмате *.js(
                                <a href="https://code.visualstudio.com/download">
                                    Visual Studio Code</a>, <a href="https://atom.io/">GitHub Atom</a>,
                                <a href="http://brackets.io/">Adobe Brackets</a>), так и в различных IDE.
                                IDE удобнее, поэтому скачиваем бесплатно <a href="https://netbeans.org/downloads/">
                                NetBeans</a> или платно
                                <a href="https://www.jetbrains.com/webstorm/download/#section=windows">
                                    JetBrain WebStorm</a>, в случае если планируется работа не только с JavaScript, но и
                                с PHP,nто можно скачать и установить
                                <a href="https://www.jetbrains.com/phpstorm/?fromMenu">
                                    JetBrains PhpStorm</a>. Кроме того, не лишним будет скачать и установить
                                <a href="https://nodejs.org">Node.js</a> и браузеры (самые удобные средства отладки
                                у Google Chrome и Mozilla Firefox).
                            </p>
                            <p>
                                Очень упрощает работу плагин <a href="https://emmet.io/">Emmet</a>, который в редакторах
                                и Net Beans можно установить с помощью системы управления плагинами, а продукты
                                JetBrains поставляются с ним &quot;из коробки&quot;.
                            </p>
                            <p>
                                Браузеры устанавливаем. Если планируете использовать для отладки Firefox, то сразу
                                устанавливайте расширение Firebug.
                            </p>
                            <p>
                                Node.js устанавливаем, а во время установки выбираем опцию добавления пути к <i>Node</i>
                                в переменную Path.
                            </p>
                            <p>
                                Затем устанавливаем редактор и/или IDE. В настройках нужно не забыть указать путь к
                                Node.js и, при необходимости, PHP.
                            </p>
                            <p>
                                Если знаете, что такое Version Control System, то установите. Вариантов несколько:
                                <a href="https://www.mercurial-scm.org">Mercurial</a>, <a href="https://git-scm.com/">
                                Git</a> и/или <a href="https://sliksvn.com/download/">Subversion</a>. Наиболее широко
                                в последнее время пиарится Git. Это не значит, что он объективно лучший выбор именно
                                для Вас, но если планируете использовать утилиту <a href="http://gulpjs.com/">Gulp</a>
                                Вам понадобится именно Git.
                            </p>
                            <p>
                                Все эти инструменты тербуют настройки, а описывать этот процесс здесь не целесообразно
                                из-за большого объема информации, которую можно найти в других местах.
                            </p>
                        </section>
                        <section>
                            <a id="ch02"></a>
                            <h2>Типы данных</h2>
                            <dl>
                                <dt>String/Строка</dt>
                                <dd>
                                    Строка это последовательность символов, заключенная в одинарные или двойные кавычки,
                                    например
                                    &quot;1256&quot;, &quot;JavaScript&quot;, &quot;n12$;lo__&quot;.
                                </dd>
                                <dt>Number/Число</dt>
                                <dd>
                                    Числа в JavaScript это обычные числа, причем в языке нет разделения на целые и
                                    действительные с одинарной и двойной точностью. С числами можно производить любые
                                    вычисления. Дробная часть числа отделяется от целой точкой (не запятой). Возможно
                                    записывать числа в виде мантиссы и порядка, например 1.02E-5, где Е-5 означает
                                    десять в минус пятой степени.
                                </dd>
                                <dt>Boolean/Логический</dt>
                                <dd>
                                    К логическому типу данных относятся только два значения: <code>true, false</code>.
                                    Логические величины используются в логических выражениях.
                                </dd>
                                <dt>Undefined/Неопределенность</dt>
                                <dd>
                                    Undefined это такое значение, которое имеет переменная до того как ей пирсвоили
                                    число, строку или др. Т.е. переменная в этом случае есть, но её значение не
                                    определено.
                                </dd>
                                <dt>NaN/Не число</dt>
                                <dd>
                                    Некое значение, которое зачастую получается при выполнении математических операций и
                                    не является числом, это часто бывает следствием ошибок, например при делении
                                    <code>0/0 = NaN</code>
                                    .
                                </dd>
                                <dt>Infinity/Бесконечность</dt>
                                <dd>
                                    Если разделим число на 0, то получим математическую бесконечность: <code>1/0 =
                                    Infinity</code>. При сложении бесконечности с любыми числами, а так же при
                                    выполнении с ней других математических операций бесконечность остаётся
                                    бесконечностью, т.е. не меняется.
                                </dd>
                                <dt>Null/Ничто</dt>
                                <dd>
                                    Значение Null не относится ни к одному описанному выше типу. Оно образует отдельный
                                    тип, состоящий из единственного значенгия, которое означает &quot;Ничто&quot;.
                                    Это не ссылка на несуществующий объект и не нулевой указатель. Это просто
                                    &quot;Ничто&quot; или &quot;Значение не известно&quot;.
                                </dd>
                                <dt>Object/Объект</dt>
                                <dd>
                                    Описанные выше типы данных предназначены для хранения одного значения, а Object
                                    предназначен для хранения сложных данных, в структуру которых могут входить
                                    переменные самых разных типой данных в том числе и другие объекты.
                                </dd>
                            </dl>
                            <p>
                                Что делать, если мы не знаем тип переменной, а нам нужно его знать? Для того, чтобы
                                узнать тип переменной нужно использовать оператор typeof. Можно использовать как
                                функцию и как оператор, при этом будет отличаться только синтаксис:<br>
                                <pre><code>typeof(x); //синтаксис функции;</code></pre>
                                <pre><code>typeof x; //синтаксис оператора.</code></pre>
                            </p>
                            <p>
                                Не зависимо от того, как Вы используете typeof в результате всегда получается строка,
                                например:
                            <pre><code>typeof(true) = &quot;boolean&quot;</code></pre>
                            </p>
                        </section>
                        <section>
                            <a id="ch03"></a>
                            <h2>Переменные.</h2>
                            <p>
                                <dfn>Переменная</dfn> (программирование) — поименованная, либо адресуемая иным способом
                                область памяти, адрес которой можно использовать для осуществления доступа к данным и
                                изменять значение в ходе выполнения программы.
                            </p>
                            <p>
                                Поскольку типы данных в JavaScript определяются динамически, при объявлении переменных
                                не нужно указавать их тип. При объявлении переменных им можно присваивать значения,
                                но это не обязательно делать именно при объявлении. Объявление переменной и присваивание
                                ей значения это два разных действия, которые интерпретатор JavaScript при выполнении
                                программы будет выполнять в разные (и не совпадающие) моменты времени.
                                При объявлении перед переменной необходимо написать ключевое слово <code>var</code>.
                                Пример объявления переменной:
                                <pre><code>var x;</code></pre>
                                Пример присвоения переменной значения:
                                <pre><code>x = 10;</code></pre>
                                Пример одновременного объявления переменной и присвоения ей значения:
                                <pre><code>var x = 10;</code></pre>
                            </p>
                            <p>
                                Важно помнить и понимать, что
                                <em>
                                    сразу после запуска скрипта все переменные в нем объявляются интерпрететором,
                                    т.е. он начинает &quot;знать&quot; что они есть, а значения переменным он
                                    присваивает когда до каждой конкретной переменной дойдет очередь при
                                    последовательном построчном выполнении скрипта.
                                </em>
                                Это может стать причиной некоторого раздражения при попытках анализа странного поведения
                                программы особенно в случаях, когда значение переменной меняется во времени как,
                                например, счетчик цикла, который используется в расчетах или должен сохраняться в
                                массиве.
                            </p>
                            <p>
                                Объявление переменной является самым простым примером <em>выражения</em> языка
                                JavaScript. Рекомендуется завершать каждое выражение символом &quot;;&quot;
                                (точка с запятой). Т.к. это только рекомендация, то допускается запись выражений и без
                                точки с запятой в конце, но во избежание странных проблем, которые взялись не понятно
                                откуда, точку с запятой нужно ставить всегда.
                            </p>
                            <p>
                                В одной строке можно объявлять сразу несколько переменных, например:
                                <pre><code>var x, y;</code></pre>
                                Объявлять можно, но если Вы хотите присвоить им значения, то присваивать нужно каждой
                                переменной отдельно. Пример правильной записи:
                                <pre><code>var x = 2, y = 3;</code></pre>
                                Пример <b>не правильной</b> записи:
                                <pre><code>var x5 = y5 = 3;</code></pre>
                                В данном случае вы получите сообщение об ошибке из-за того, что не объявили переменную
                                <code>y</code> до использования в выражении. Другими словами следующий код будет
                                верным:
                                <pre><code>var y;<br>var x = y = 5;</code></pre>
                                При таком использовании мы получим две независимые переменные, но с одинаковым
                                значением.
                            </p>
                            <p>
                                Имена переменных должны соответствовать ряду требований:
                            </p>
                            <ol>
                                <li>
                                    Имя переменной должно состоять только из латинских букв, цифр и символов
                                    подчеркивания.
                                </li>
                                <li>
                                    Имя переменной должно начинаться с буквы или символа подчеркивания, но не с цифры.
                                </li>
                                <li>
                                    Имя переменной должно быть осмысленным и по нему должно быть понятно её
                                    предназначение.
                                </li>
                                <li>
                                    Транслитерация считается плохим тоном, т.е. имя переменной должно быть переведено на
                                    английский
                                    язык.
                                </li>
                                <li>Не допускается совпадение имени переменной с ключевыми словами языка.</li>
                                <li>Регистр символов учитывается!</li>
                            </ol>
                        </section>
                        <section>
                            <a id="ch04"></a>
                            <h2>Операторы.</h2>
                            <dl>
                                <dt>Арифметические операторы</dt>
                                <dd>
                                    Арифметические операторы служат для выполнения арифметических действий <em>над
                                    числами</em>. Они делятся на две группы: <em>унарные</em> и <em>бинарные</em>.
                                    <br>
                                    <table class="table_col">
                                        <caption>Арифметические операторы</caption>
                                        <colgroup>
                                            <col style="background:#f9ebfa;">
                                        </colgroup>
                                        <thead>
                                            <tr>
                                                <th>Оператор</th>
                                                <th>Описание</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>-</td>
                                                <td>Смена знака (унарный)</td>
                                            </tr>
                                            <tr>
                                                <td>-</td>
                                                <td>Вычитание (бинарный)</td>
                                            </tr>
                                            <tr>
                                                <td>+</td>
                                                <td>Сложение (бинарный)</td>
                                            </tr>
                                            <tr>
                                                <td>*</td>
                                                <td>Умножение (бинарный)</td>
                                            </tr>
                                            <tr>
                                                <td>/</td>
                                                <td>Деление (бинарный)</td>
                                            </tr>
                                            <tr>
                                                <td>%</td>
                                                <td>Взятие остатка от деления (бинарный)</td>
                                            </tr>
                                            <tr>
                                                <td>++</td>
                                                <td>Инкремент (унарный)</td>
                                            </tr>
                                            <tr>
                                                <td>--</td>
                                                <td>Декремент (унарный)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </dd>
                                <dt>Оператор объединения строк</dt>
                                <dd>
                                    Оператор объединения строк &quot;+&quot; позволяет соединить две и более строк
                                    в одну. Например, сценарий:
                                    <pre><code>str1 = 'Java';<br>str2 = 'Script';<br>str3 = str1 + str2;</code></pre>
                                    Поместит в переменную <code>str3</code> значение
                                    <code>&quot;JavaScript&quot;</code>
                                </dd>
                                <dt>Двоичные операторы</dt>
                                <dd>
                                    Двоичные (побитные) операторы датрагивают двоичное представление чисел и
                                    используются для низкоуровневого программирования.
                                    <p>
                                        В побитовых операторах операндами являются 32-х битные целые числа,
                                        трактуемые интерпретатором как последовательность 0 и 1 (двоичное
                                        представление числа). Точнее это называется: &quot;32-битное целое со
                                        знаком, старшим битом слева и дополнением до двойки&quot;. Это означает
                                        следующее:
                                    </p>
                                    <ol>
                                        <li>Если в десятичной системе исчисления число имеет дробную часть, то она
                                            отбрасывается.
                                        </li>
                                        <li>Целая часть числа превращается в двоичную форму, при этом самый старший
                                            (левый) бит у положительного числа будет равен 0, а у отрицательного
                                            числа - 1.
                                        </li>
                                        <li>Двоичный вид числа, обратного, например 3, т.е. -3 получается в
                                            результате обращения всех битов числа 3 и добавления 1.<br>
                                            Пример:
                                            <pre><code>a = 3; //00000000000000000000000000000011</code></pre>
                                            <pre><code>a = -3; //11111111111111111111111111111101</code></pre>
                                        </li>
                                    </ol>
                                    <p>
                                        Функция для преобразования строки с двоичным числом в десятичное число:
                                        <pre><code>parseInt(&quot;1011101&quot;, 2);</code></pre>
                                    </p>
                                    <p>
                                        Функция для преобразования десятичного числа <em>n</em> в двоичное
                                        представление:
                                    <pre><code>n.toString(2);</code></pre>
                                    </p>
                                    <table class="table_col">
                                        <caption>Двоичные операторы</caption>
                                        <colgroup>
                                            <col style="background:#f9ebfa;">
                                        </colgroup>
                                        <thead>
                                            <tr>
                                                <th>Оператор</th>
                                                <th>Описание</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>~</td>
                                                <td>НЕ (двоичная инверсия, унарный)</td>
                                            </tr>
                                            <tr>
                                                <td>&amp;</td>
                                                <td>И (двоичное умножение, бинарный)</td>
                                            </tr>
                                            <tr>
                                                <td>|</td>
                                                <td>ИЛИ (двоичное сложение, бинарный)</td>
                                            </tr>
                                            <tr>
                                                <td>^</td>
                                                <td>Исключающее или (бинарный)</td>
                                            </tr>
                                            <tr>
                                                <td>&lt;&lt;</td>
                                                <td>Сдвиг влево с заполнением нулями младших разрядов (бинарный)</td>
                                            </tr>
                                            <tr>
                                                <td>&gt;&gt;</td>
                                                <td>Сдвиг вправо с заполнением старших разрядов содержимым знакового
                                                    (самого старшего) разряда (бинарный)
                                                </td>
                                            </tr>
                                            <tr>
                                                <td>&gt;&gt;&gt;</td>
                                                <td>Сдвиг вправо с заполнение старших разрядов нулями (бинарный)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>
                                        В операторах сдвига второй операнд задаёт количество разрядов, на котоое
                                        выполняется сдвиг.
                                    </p>
                                    <p>
                                        Побитовое И выполняет операцию И над каждой парой бит двух операндов.
                                        В результате бит получает значение 1 если и в первом и во втором операнде
                                        этот бит равен 1.
                                    </p>
                                    <p>
                                        Побитовое ИЛИ выполняет операцию ИЛИ над каждой парой бит. В результате в
                                        бит будет помещена 1 если хотя бы один из битов пары равен 1.
                                    </p>
                                    <p>
                                        Исключающее ИЛИ выполняет операцию Исключающее ИЛИ над каждой парой бит. В
                                        результате в бит будет помещена 1 если только один из сравниваемых битов
                                        пары равен 1.
                                    </p>
                                    <p>
                                        Побитовое НЕ (унарный оператор) обращает биты числа.
                                    </p>
                                    <p>
                                        Битовый сдвиг влево сдвигает первый операнд на указанное во втором операнде
                                        количество бит влево. Лишние левые биты отбрасываются, а добавляемые справа
                                        биты заполняются 0.
                                    </p>
                                    <p>
                                        Битовый сдвиг вправо (&gt;&gt;) сдвигает первый операнд на указанное во
                                        втором операнде количество бит вправо. Лишние (правые) биты теряются, слева
                                        биты заполняются содержимым самого старшего (знакового) бита, т.е. если
                                        число положительное то 0, а если отрицательное - то 1.
                                    </p>
                                    <p>
                                        Вторая разновидность правого битового сдвига (&gt;&gt;&gt;) заполняет правые
                                        биты не содержимым знакового бита а 0 (всегда).
                                    </p>
                                </dd>
                                <dt>Операторы присваивания</dt>
                                <dd>
                                    Операторы присваивания могут выполнять как само по седе присваивание, так и
                                    дополнительную операцию с последующим присваиванием.
                                    <table class='table_col'>
                                        <caption>Операторы присваивания</caption>
                                        <colgroup>
                                            <col style="background:#f9ebfa;">
                                        </colgroup>
                                        <thead>
                                            <tr>
                                                <th>Оператор</th>
                                                <th>Описание</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>a += b;</td>
                                                <td>a = a + b;</td>
                                            </tr>
                                            <tr>
                                                <td>a -+ b;</td>
                                                <td>a = a - b;</td>
                                            </tr>
                                            <tr>
                                                <td>a *= b;</td>
                                                <td>a = a * b;</td>
                                            </tr>
                                            <tr>
                                                <td>a /= b;</td>
                                                <td>a = a / b;</td>
                                            </tr>
                                            <tr>
                                                <td>a %= b;</td>
                                                <td>a = a % b;</td>
                                            </tr>
                                            <tr>
                                                <td>a &lt;&lt;= b;</td>
                                                <td>a = a &lt;&lt; b;</td>
                                            </tr>
                                            <tr>
                                                <td>a &gt;&gt;= b;</td>
                                                <td>a = a &gt;&gt; b;</td>
                                            </tr>
                                            <tr>
                                                <td>a &gt;&gt;&gt;= b;</td>
                                                <td>a = a &gt;&gt;&gt; b;</td>
                                            </tr>
                                            <tr>
                                                <td>a &amp;= b;</td>
                                                <td>a = a &amp; b;</td>
                                            </tr>
                                            <tr>
                                                <td>a ^= b;</td>
                                                <td>a = a ^ b;</td>
                                            </tr>
                                            <tr>
                                                <td>a |= b;</td>
                                                <td>a = a | b;</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                </dd>
                                <dt>Операторы сравнения</dt>
                                <dd>
                                    Сравнивают два операнда и возвращают логическое значение (true/false).
                                    <table class='table_col'>
                                        <caption>Операторы сравнения</caption>
                                        <colgroup>
                                            <col style="background:#f9ebfa;">
                                        </colgroup>
                                        <thead>
                                            <tr>
                                                <th>Оператор</th>
                                                <th>Описание</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td>&lt;</td>
                                                <td>Меньше</td>
                                            </tr>
                                            <tr>
                                                <td>&gt;</td>
                                                <td>Больше</td>
                                            </tr>
                                            <tr>
                                                <td>==</td>
                                                <td>Равно</td>
                                            </tr>
                                            <tr>
                                                <td>&lt;=</td>
                                                <td>Меньше или равно</td>
                                            </tr>
                                            <tr>
                                                <td>&gt;=</td>
                                                <td>Больше или равно</td>
                                            </tr>
                                            <tr>
                                                <td>!=</td>
                                                <td>Не равно</td>
                                            </tr>
                                            <tr>
                                                <td>===</td>
                                                <td>Строго равно (сравниваются величины и типы операндов)</td>
                                            </tr>
                                            <tr>
                                                <td>!==</td>
                                                <td>Строго не равно (сравниваются величины и типы операндов)</td>
                                            </tr>
                                    </table>
                                    <p>
                                        Со сравнением чисел всё должно быть понятно. Интересно рассмотреть сравнение
                                        строк между собой, а так же строк с числами и.т.д.
                                    </p>
                                    <p>
                                        Сравнению в таких случаях подвергаются не символы строки как таковые, а их
                                        коды. Важно: <strong>JavaScript использует кодировку Unicode</strong>.
                                    </p>
                                    <p>
                                        При выполнении всех видов сравнений, кроме строгих, происходит
                                        автоматическое приведение типов к числовому типу и потом эти числа
                                        сравниваются. Сравнение двух строк производится посимвольно. Если код
                                        первого символа одного из операндов больше чем код первого символа второго
                                        операнда, то сравнение заканчивается и выдаётся результат в виде логического
                                        значения. Если коды первых символов равны, производится сравнение кодов
                                        вторых символов и т.д. до завершения сравнения всех символов.
                                    </p>
                                    <p>
                                        Т.к. коды строчных букв больше, чем, соответственно, прописных, то процесс
                                        сравнения зависит от регистра символов. Например выражение:
                                    <pre><code>console.log(&quot;a&quot; &gt; &quot;A&quot;); //true</code></pre>
                                    Чтобы не возникало необходимости искать причины странного сравнения,
                                    сравниваемые строки должны быть в одинаковом регистре.
                                    </p>
                                    <p>
                                        А что если нужно сравнить числа, которые храняться как строки, например
                                        &quot;9&quot; и &quot;11&quot;? Если сравнивать эти строки посимвольно, то
                                        на первом шаге будет сравниваться код символа &quot;9&quot; с кодом символа
                                        &quot;1&quot;, а он больше... Получается, что сравнение должно завершится
                                        после первого шага с результатом, основанным на сравнении первых символов,
                                        а именно &quot;9&quot; &gt; &quot;11&quot;? Мы с таким результатом не
                                        согласны и мириться не будем. Мы явно преобразует строки в числа с
                                        помощью символа &quot;+&quot; перед строками:
                                        <pre><code>console.log(+&quot;9&quot; &gt; +&quot;11&quot;); //false</code></pre>
                                        При явном преобразовании строк в числа, будут сравниваться не коды символов,
                                        а полученные числа.
                                    </p>
                                    <p>
                                        Логические значения при сравнениях преобразовываются true = 1 и,
                                        соответственно, false = 0. Т.е
                                    <pre><code>console.log(true > 9); //false</code></pre>
                                    </p>
                                    <p>
                                        Специальные значения Null и undefined при сравнениях между собой будут
                                        равны, но они не будут равны больше никакому другому числу. Даже не смотря
                                        на то, что Null при числовом преобразовании превращается в 0, он не будет
                                        равен 0 при сравнении. Значение undefined при числовом преобразовании
                                        становится NaN. При сравнении его с чем либо в результате всегда будет
                                        получаться false.
                                    </p>
                                    <p>
                                        Учитывая &quot;особенность&quot; специальных значений Null и undefined,
                                        сравнения с ними лучше производить с помощью операторов &quot;===&quot; и
                                        &quot;!==&quot; во избежание ошибок.
                                    </p>
                                    <p>
                                        Для чего же нужно было вводить операторы строгого равенства и строгого
                                        неравенства &quot;===&quot; и &quot;!==&quot;? Эти операторы учитывают типы
                                        операндов. Так, если при обычном сравнении выражение
                                        <pre><code>console.log(false == &quot;&quot;); //true</code></pre>
                                        (т.е. для оператора &quot;==&quot; понятие &quot;false&quot; и пустая строка
                                        это одно и тоже), то при строгом сравнении мы получаем возможность отличать
                                        false от 0 и/или пустой строки.
                                    </p>
                                </dd>
                                <dt>Логические операторы</dt>
                                <dd>
                                    <p>
                                        Выполняют действия над, как правило, логическими значениями. Результатами
                                        выполнения являются так же, как правило, логические значения.
                                    </p>
                                    <p>
                                        Здесь оговорка &quot;как правило&quot; имеет место из-за того, что
                                        логические операторы могут работать с операндами разных типов, а не только
                                        с логическими. Кроме того они могут возвращать не только логические
                                        значения.
                                    </p>
                                    <table class="table_col">
                                        <caption>Логические операторы</caption>
                                        <colgroup>
                                            <col style="background:#f9ebfa;">
                                        </colgroup>
                                        <thead>
                                            <tr>
                                                <th>Оператор</th>
                                                <th>Описание</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            <tr>
                                                <td class='center'>!</td>
                                                <td>НЕ (логическая инверсия, унарный)</td>
                                            </tr>
                                            <tr>
                                                <td class='center'>&amp;&amp;</td>
                                                <td>И (логическое умножение, бинарный)</td>
                                            </tr>
                                            <tr>
                                                <td class='center'>||</td>
                                                <td>ИЛИ (логическое сложение, бинарный)</td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <p>
                                        В самом очевидном случае, логические операторы работают с логическими
                                        операндами. При этом результат имеет тоже логическое значение. Если операнды
                                        не являются логическими значениями, то результат будет иметь тип операнда.
                                    </p>
                                    <p>
                                        Существует понятие <dfn>короткого цикла вычислений</dfn>, которе применимо с
                                        операторам &quot;||&quot; и &quot;&amp;&amp;&quot;. Суть в том, что если
                                        проверяется цепочка условий, то проверка будет продолжаться до первого
                                        истинного значения, а остальные проверки проводиться не будут.
                                    </p>
                                    <p>
                                        Оператор логического ИЛИ &quot;||&quot; работает следующим образом: &quot;
                                        Если хотя бы один из операндов равен true, то возвращается true, иначе
                                        возвращается false&quot;. Применяется он чаще всего при проверках условий:
                                        <pre><code>if (condition1 || condition2) {...}</code></pre>
                                    </p>
                                    <p>
                                        При выполнении цепочки проверок, оператор ИЛИ остановится при первом
                                        результате true и вернет его. Если операнды были не логического типа, то
                                        вернется не логическое значение, а тот операнд, на котором было остановлено
                                        вычисление и тип его не преобразовуется в логический. Если все значения
                                        окажутся ложными, то вернется последний операнд. Это можно использовать для
                                        получения первого истинного значения из списка не логических значений.
                                    </p>
                                    <p>
                                        Оператор логического И &quot;&amp;&amp;&quot; работает по принципу: &quot;
                                        Если оба операнда true то результат тоже true&quot;. В цепочке проверок если
                                        первый операнд false, то проверка будет остановлена, будет возвращено
                                        значение false, а если первый операнд true, то будет проверяться второй
                                        операнд. Если второй операнд false, то резульатом будет false и дальнейшая
                                        проверка будет прекращена.
                                    </p>
                                    <p>
                                        Если операнды имеют не логический тип, то при цепочке проверок будет
                                        возвращен тот операнд, на котором была прекращена проверка, т.е. тот,
                                        значение которого при преобразовании к логическому типу интерпретируется как
                                        false. Т.е. оператор логического И возвращает первый false операнд в цепочке,
                                        в отличие от оператора логического ИЛИ, который возвращает первый true
                                        операнд в цепочке.
                                    </p>
                                    <p>
                                        Может возникнуть соблазн использовать конструкции вроде:
                                        <pre><code>(someVar > anotherVar) && doSomeThing();</code></pre>
                                        Эта конструкция работает так: если резульат в скобках true, то выполнится
                                        doSomeThing() потому, что это конец цепочки проверок. Т.е. это извращенный
                                        вариант конструкции <code>if (...) {...}</code>. Не нужно писать такой код
                                        т.к. он весьма не очевиден по сравнению с блоком if...
                                    </p>
                                    <p>
                                        Оператор логического НЕ &quot;!&quot; получает один операнд, приводит его,
                                        при необходимости, к логическому типу, а затем возвращает противоположное
                                        значение. Двойное логическое отрицание можно использовать для преобразования
                                        к логическому типу.
                                    </p>
                                </dd>
                                <dt>Оператор получения типа &quot;typeof&quot;</dt>
                                <dd>
                                    Оператор получения типа <code>t = typeof variable;</code> возвращает строку,
                                    описывающую тип операнда. Как отмечалось <a href="#ch02">ранее</a> может
                                    использоваться с синтаксисом оператора или с синтаксисом функции.
                                </dd>
                            </dl>
                        </section>
                        <section>
                            <a id="ch05"></a>
                            <h2>Приоритет операторов.</h2>
                            <p>
                                JavaScript имеет понятие о приоритете операторов, т.е. как и в математике сложные выражения,
                                состоящие
                                из большого количества операндов и операторов выполняются не слева на право, а в соотвествии и
                                приоритетами применяемых операторов. В таблице ниже представлены все операторы с указанием
                                приоритета.
                                Операторы с б<b>о</b>льшим приоритетом выполняются раньше.
                            </p>
                            <p>
                                Наиболее актуальную информацию можно посмотреть на
                                <a target="_blank"
                                   href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence">
                                    https://developer.mozilla.org
                                </a>
                            </p>
                            <table class="table_col">
                                <caption>Приоритеты операторов</caption>
                                <colgroup>
                                    <col style="background:#f9ebfa;">
                                </colgroup>
                                <thead>
                                    <tr>
                                        <th>Приоритет</th>
                                        <th style="width: 14em">Оператор</th>
                                        <th style="width: 26em">Описание оператора</th>
                                        <th>принцип действия</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>20</td>
                                        <td><code>( … )</code></td>
                                        <td><code>Grouping</code></td>
                                        <td>n/a</td>
                                    </tr>
                                    <tr>
                                        <td rowspan="3">19</td>
                                        <td><code>… . …</code></td>
                                        <td><code>Member Access</code></td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>… [ … ]</code></td>
                                        <td><code>Computed Member Access</code></td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>new … ( … )</code></td>
                                        <td><code>new</code> (with argument list)</td>
                                        <td>n/a</td>
                                    </tr>
                                    <tr>
                                        <td rowspan="2">18</td>
                                        <td><code>… (&nbsp;<var>…&nbsp;</var>)</code></td>
                                        <td>Function Call</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>new …</code></td>
                                        <td><code>new</code>&nbsp;(without argument list)</td>
                                        <td>right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td rowspan="2">17</td>
                                        <td><code>… ++</code></td>
                                        <td><code>Postfix Increment</code></td>
                                        <td>n/a</td>
                                    </tr>
                                    <tr>
                                        <td><code>… --</code></td>
                                        <td><code>Postfix Decrement</code></td>
                                        <td>n/a</td>
                                    </tr>
                                    <tr>
                                        <td rowspan="9">16</td>
                                        <td><code>! …</code></td>
                                        <td>Logical NOT</td>
                                        <td>right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td><code>~ …</code></td>
                                        <td>Bitwise NOT</td>
                                        <td>right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td><code>+ …</code></td>
                                        <td>Unary Plus</td>
                                        <td>right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td><code>- …</code></td>
                                        <td>Unary Negation</td>
                                        <td>right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td><code>++ …</code></td>
                                        <td>Prefix Increment</td>
                                        <td>right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td><code>-- …</code></td>
                                        <td>Prefix Decrement</td>
                                        <td>right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td><code>typeof …</code></td>
                                        <td>typeof</td>
                                        <td>right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td><code>void …</code></td>
                                        <td>void</td>
                                        <td>right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td><code>delete …</code></td>
                                        <td>delete</td>
                                        <td>right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td>15</td>
                                        <td><code>… ** …</code></td>
                                        <td>Exponentiation</td>
                                        <td>right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td rowspan="3">14</td>
                                        <td><code>… *&nbsp;…</code></td>
                                        <td>Multiplication</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>… /&nbsp;…</code></td>
                                        <td>Division</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>… %&nbsp;…</code></td>
                                        <td>Remainder</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td rowspan="2">13</td>
                                        <td><code>… +&nbsp;…</code></td>
                                        <td>Addition</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>… -&nbsp;…</code></td>
                                        <td>Subtraction</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td rowspan="3">12</td>
                                        <td><code>… &lt;&lt;&nbsp;…</code></td>
                                        <td>Bitwise Left Shift</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>… &gt;&gt;&nbsp;…</code></td>
                                        <td>Bitwise Right Shift</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>… &gt;&gt;&gt;&nbsp;…</code></td>
                                        <td>Bitwise Unsigned Right Shift</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td rowspan="6">11</td>
                                        <td><code>… &lt;&nbsp;…</code></td>
                                        <td>Less Than</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>… &lt;=&nbsp;…</code></td>
                                        <td>Less Than Or Equal</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>… &gt;&nbsp;…</code></td>
                                        <td>Greater Than</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>… &gt;=&nbsp;…</code></td>
                                        <td>Greater Than Or Equal</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>… in&nbsp;…</code></td>
                                        <td>in</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>… instanceof&nbsp;…</code></td>
                                        <td>instanceof</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td rowspan="4">10</td>
                                        <td><code>… ==&nbsp;…</code></td>
                                        <td>Equality</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>… !=&nbsp;…</code></td>
                                        <td>Inequality</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>… ===&nbsp;…</code></td>
                                        <td>Strict Equality</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td><code>… !==&nbsp;…</code></td>
                                        <td>Strict Inequality</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td>9</td>
                                        <td><code>… &amp;&nbsp;…</code></td>
                                        <td>Bitwise AND</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td>8</td>
                                        <td><code>… ^&nbsp;…</code></td>
                                        <td>Bitwise XOR</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td>7</td>
                                        <td><code>… |&nbsp;…</code></td>
                                        <td>Bitwise OR</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td>6</td>
                                        <td><code>… &amp;&amp;&nbsp;…</code></td>
                                        <td>Logical AND</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td>5</td>
                                        <td><code>… ||&nbsp;…</code></td>
                                        <td>Logical OR</td>
                                        <td>left-to-right</td>
                                    </tr>
                                    <tr>
                                        <td>4</td>
                                        <td><code>… ? … : …</code></td>
                                        <td>Conditional</td>
                                        <td>right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td rowspan="13">3</td>
                                        <td><code>… =&nbsp;…</code></td>
                                        <td rowspan="13">Assignment</td>
                                        <td rowspan="13">right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td><code>… +=&nbsp;…</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>… -=&nbsp;…</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>… **=&nbsp;…</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>… *=&nbsp;…</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>… /=&nbsp;…</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>… %=&nbsp;…</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>… &lt;&lt;=&nbsp;…</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>… &gt;&gt;=&nbsp;…</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>… &gt;&gt;&gt;=&nbsp;…</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>… &amp;=&nbsp;…</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>… ^=&nbsp;…</code></td>
                                    </tr>
                                    <tr>
                                        <td><code>… |=&nbsp;…</code></td>
                                    </tr>
                                    <tr>
                                        <td rowspan="2">2</td>
                                        <td><code>yield&nbsp;…</code></td>
                                        <td>yield</td>
                                        <td>right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td><code>yield*&nbsp;…</code></td>
                                        <td>yield*</td>
                                        <td>right-to-left</td>
                                    </tr>
                                    <tr>
                                        <td>1</td>
                                        <td><code>...</code>&nbsp;…</td>
                                        <td>Spread</td>
                                        <td>n/a</td>
                                    </tr>
                                    <tr>
                                        <td>0</td>
                                        <td><code>… ,&nbsp;…</code></td>
                                        <td>Comma / Sequence</td>
                                        <td>left-to-right</td>
                                    </tr>
                                </tbody>
                            </table>
                        </section>
                        <section>
                            <a id="ch06"></a>
                            <h2>Преобразования типов</h2>
                            <p>
                                Ранее отмечалось, что JavaScript поддерживает следующие типы данных: строки, числа,
                                логический тип, undefined, NaN, Infinity, Null, Object. Интерпретатор самостоятельно
                                определяет тип переменной после присвоения ей значения. Одной и той же переменной в
                                разных местах программы могут присваиваться значения разных типов, т.е. тип данных,
                                записанных в переменную не является постоянным. В связи с этим могут возникать ситуации,
                                когда в выражениях используются переменные не согласующихся типов данных, например числа
                                и строки и т.п. Далее в этом разделе будем рассматривать &quot;простые&quot; типы
                                данных.
                            </p>
                            <p>
                                Система преобразования типов в JavaScript отличается от других языков, она проста и
                                содержит три вида преобразований:
                            </p>
                            <ol>
                                <li>Строковое преобразование.</li>
                                <li>Числовое преобразование.</li>
                                <li>Преобразование к логическому значению.</li>
                            </ol>
                            <p>
                                <strong>Строковое преобразование</strong> происходит в момент, когда значение некоторой
                                переменной необходимо представить в виде строки, как например в выражении
                                <pre><code>console.log(&quot;Ставка, &quot; + rate);</code></pre>
                                где <code>rate</code> - некая переменная, содержащая число. В случае, например,
                                логического значения выражение может быть следующим:
                                <pre><code>console.log(true);</code></pre>.
                                В обоих случаях преобразование производится интерпретатором не явно.
                            </p>
                            <p>
                                Такие преобразования производятся наиболее очевидным образом:
                            </p>
                            <ul>
                                <li>false -> &quot;false&quot;</li>
                                <li>true -> &quot;true&quot;</li>
                                <li>Null -> &quot;Null&quot;</li>
                                <li>undefined -> &quot;undefined&quot;</li>
                                <li>NaN -> &quot;NaN&quot;</li>
                                <li>Infinity -> &quot;Infinity&quot;</li>
                            </ul>
                            <p>
                                Для явного преобразования в строку можно использовать два способа: во-первых, с помощью
                                такой записи
                                <pre><code>str = String(someValue);</code></pre>
                                во-вторых, с помощью оператора &quot;+&quot;, у которого один из операндов - строка.
                            </p>
                            <p>
                                <strong>Числовое преобразование</strong> происходит в математических функциях и
                                выражениях, а также при сравнении данных различных типов кроме &quot;строгих&quot;
                                стравнений (===, !==).
                            </p>
                            <ul>
                                <li>false -> 0</li>
                                <li>true -> 1</li>
                                <li>Null -> 0</li>
                                <li>undefined -> NaN</li>
                                <li>NaN -> NaN</li>
                                <li>Infinity -> Infinity</li>
                                <li>String -> Пробельные символы по краям обрезаются, если при этом остается пустая
                                    строка, то 0 иначе из непустой строки считывается число (если оно там есть), при
                                    ошибке NaN.
                                </li>
                            </ul>
                            <p>
                                При выполнении операций сравнения (кроме строгих) так же происходит неявное
                                преобразование к числовому типу.
                            </p>
                            <p>
                                Для явного преобразования в число можно использовать запись:
                                <pre><code>num = Number(&quot;123&quot;);</code></pre>
                                Второй вариант - использование унарного &quot;+&quot; перед превращаемым значением в
                                выражениях типа <pre><code>var x = +&quot;123&quot;;</code></pre>
                            </p>
                            <p>
                                Нужно помнить, что при работе со значениями типа Null и undefined есть тонкости. Null
                                будет преобразовано в 0, а undefined - в NaN. При арифметических операциях и сравнениях
                                вида: &lt;, &gt;, &lt;=, &gt;= так и будет происходить, а вот при проверке на равенство
                                == эти значения будут равны между собой, но не равны никаким другим значениям.
                            </p>
                            <p>
                                undefined при любых сравнениях приведет к false, Null же ведет себя интереснее:<br>
                                <pre><code>console.log(null &gt;= 0); //true</code></pre>
                                <pre><code>console.log(null &gt; 0); //false</code></pre>
                                <pre><code>console.log(null == 0); //false</code></pre>
                            </p>
                            <p>
                                Т.е. Null больше и равен нулю, но он не больше нуля и не равен ему.
                            </p>
                            <p>
                                <strong>Логическое преобразование</strong> происходит в выражениях вида
                                <code>if(value)</code>. Значения: Null, undefined, NaN, 0 и пустая строка (&quot;&quot;)
                                становятся равны false. Все остальные значения станут равны true. Следует иметь ввиду,
                                что строка &quot;0&quot; и строка &quot;пробел&quot; превратятся в true в отличие от
                                других языков программирования.
                            </p>
                            <p>
                                Явное преобразование производится с помощью выражения <code>Boolean(value)</code>, а
                                также двойного логического отрицания <code>!!value</code>.
                            </p>
                            <p>
                                Может возникнуть путаница из-за разной трактовки значений в операциях сравнения и в
                                логических операциях, например
                                <pre><code>console.log(0 == '0'); //true</code></pre>
                                в то время как с точки зрения логический операции число 0 (нуль) это <samp>false</samp>,
                                а строка &quot;0&quot; это <samp>true</samp>. Т.е. при сравнении <code>(0 == '0')</code>
                                <pre><code>console.log(false == true); // получим true ?!!!</code></pre>
                                <b>Но</b> давайте помнить, что в сравнениях с помощью операторов &lt;, &gt; и т.п
                                происходит числовое преобразование, а в выражении <code>if (&quot;0&quot;) {...}</code>
                                - логическое преобразование и это разные преобразования.
                            </p>
                        </section>
                        <section>
                            <a id="ch07"></a>
                            <h2>Сложные выражения JavaScript</h2>
                            <section>
                                <a id="ch07.01"></a>
                                <h3>Блоки (<code>{}</code>)</h3>
                                <p class="text">
                                    Блоки служат для объединения нескольких простых выражений в одно более сложное. Блоком
                                    называется последовательность выражений, заключенная в фигурные скобки <code>{}</code>. Сами
                                    по себе блоки не применяются, но они очень широко применяются в составе условных выражений,
                                    выражений выбора, циклов, функций и т.д.
                                </p>
                            </section>
                            <section>
                                <a id="ch07.02"></a>
                                <h3>Условные выражения (<code>if (condition) {...} else {...}</code>)</h3>
                                <p class="text">
                                    <dfn>Условное выражение</dfn> даёт возможность выполнить одно из двух входящих в него выражений
                                    (простых или сложных) в зависимости от выполнения или невыполнения какого либо условия.
                                    Существует также упрощенная разновидность условного выражения, содержащая только одно выражение,
                                    которое выполняется, если условие истинно или пропускается, если условие ложно. Синтаксис
                                    условного выражения следующий:<br>
                                    <code>
                                        if (condition) {<br>
                                        ...блок ТО...<br>
                                        } else {<br>
                                        ...блок ИНАЧЕ...<br>
                                        }<br>
                                        ...
                                    </code><br>
                                    Или в упрощенной форме:<br>
                                    <code>
                                        if (condition) {<br>
                                        ...блок ТО...<br>
                                        }<br>
                                        ...
                                    </code>
                                </p>
                                <p class="text">
                                    Для улучшения читаемости кода блоки все следует заключать в фигурные скобки.
                                </p>
                                <p class="text">
                                    Оператор <code>if (...)</code> вычисляет и преобразует выражение в скобках (условие) к
                                    логическому типу. При этом 0, пустая строка &quot;&quot;, null и undefined, а также NaN
                                    являются false, а все остальные значения будут равны true.
                                </p>
                                <p class="text">
                                    Блок <code>else {...}</code> не является обязательным и выполнятеся, когда в результате
                                    проверки условия получено значение false.
                                </p>
                                <p class="text">
                                    Выражения <code>if (...)...</code> можно связывать в цепочки для проверки нескольких
                                    условий:<br>
                                    <code>
                                        if (condition1) {<br>
                                        ... блок ТО ...<br>
                                        } else if (condition2) {<br>
                                        ... блок ТО 2 ...<br>
                                        } else if (condition3) {<br>
                                        ... блок ТО 3 ...<br>
                                        }<br>
                                    </code>
                                </p>
                                <p class="text">
                                    Поскольку undefined интерпретируется как false, то с помощью оператора <code>if(someVar)</code>
                                    можно проверить была ли переменная someVar инициализирована (если переменная не была объявлена,
                                    то мы получим сообщение об ошибке).
                                </p>
                            </section>
                            <section>
                                <a id="ch07.03"></a>
                                <h3>Условый оператор (<code>(condition) ? expression #1 : expression #2</code>)</h3>
                                <p class="text">
                                    Для простых случаев выбора можно применять условтый оператор:<br>
                                    <code>(condition) ? expression #1 : expression #2;</code><br>
                                    Это удобно когда в зависимости от выполнения условия нужно присвоить значение переменной.
                                </p>
                                <p class="text">
                                    Условные операторы можно объединять в цепочки. Это работает но читать такой код достаточно
                                    сложно т.к. требует повышенного внимания. Значительно легче воспринимается условное выражение:
                                    <br><code>if (...) {...} else if (...) {...}</code>.
                                </p>
                                <p class="text">
                                    Общая рекомендация следующая: если контекст позволяет использовать if вместо ?:, то лучше
                                    использовать if.
                                </p>
                            </section>
                            <section>
                                <a id="ch07.04"></a>
                                <h3>Выражение выбора (<code>switch (condition) ... case: ...</code>)</h3>
                                <p class="text">
                                    <dfn>Выражение выбора</dfn> способно заменить несколько <code>if(...) {...} else {...}</code> и
                                    представляет собой способ, в зависимости от значения некоторой переменной, выбрать хотя бы одну
                                    из многих веток кода для исполнения.
                                </p>
                                <p class="text">
                                    Синтаксис:<br>
                                    <code>
                                        switch(someVar) {<br>
                                        case 'value1' :<br>
                                        ...<br>
                                        break;<br>
                                        case 'value2' :<br>
                                        ...<br>
                                        break;<br>
                                        case 'value2' :<br>
                                        ...<br>
                                        break;<br>
                                        default:<br>
                                        ...<br>
                                        break;<br>
                                        }<br>
                                    </code>
                                </p>
                                <p class="text">
                                    Принцип работы следующий: результат вычисления выражения someVar последовательно сравнивается с
                                    value1 затем с value2, затем с value3, затем с default. Если такое сравнение увенчалось успехом,
                                    выполняется блок кода, следующий за соответствующим case. Если не увенчалось, то выполняется
                                    блок кода default (если он существует).
                                </p>
                                <p class="text">
                                    Встретив оператор прерывания <code>break;</code>, интерпретатор прерывает выполнение блока, в
                                    котором оно присутствует, выходит из выражения выбора и продолжает работу с кода после выражения
                                    выбора. Если этот оператор опустить, то выполнится следующий блок <code>case...</code>. Если
                                    забыть оператор <code>break;</code> во всех блоках <code>case...</code>, то они выполнятся все
                                    поочереди, причем проверки при этом игнорируются.
                                </p>
                                <p class="text">
                                    Если <code>someVar</code> имеет числовой тип, то и <code>value</code> тоже должно иметь
                                    числовой тип. Если <code>someVar</code> является строкой, то и <code>value</code> тоже должно
                                    быть строкой и.т.д. Тип имеет значение.
                                </p>
                            </section>
                            <section>
                                <a id="ch07.05"></a>
                                <h3>Цикл со счетчиком (<code>for (...) {...}</code>)</h3>
                                <p class="text">
                                    <dfn>Цикл со счетчиком</dfn> используется, когда какой-либо код нужно выполнить какое-то
                                    определенное количество раз, причем это количество нужно знать заранее. Это наиболее часто
                                    используемый тип цикла.
                                </p>
                                <p class="text">
                                    Синтаксис:<br>
                                    <code>
                                        for (var i = 0, i < 10; ++i) {<br>
                                        ... тело цикла<br>
                                        }<br>
                                    </code>
                                    Здесь:<br>
                                    <code>var i = 0</code> - объявление счетчика цикла и инициализация его 0.<br>
                                    <code>i < 10</code> - условие, т.е. цикл будет выполняться до тех пор пока счетчик меньше
                                    10.<br>
                                    <code>++i</code> - приращение счетчика цикла на каждой итерации, оно может быть другим,
                                    например <code>i += 2</code>.<br>
                                </p>
                                <p class="text">
                                    Часто условие может задаваться не константой, как предыдущем примере, а вычиляться, например,
                                    при необходимости перебора всех элементов массива можно в качестве условия задать
                                    <code>i < arr.length</code>, но такая запись приведет к тому, что на каждой итерации будет
                                    вычисляться arr.length. Если массив большой, то это может занимать значительное время. Чтобы
                                    избежать такого эффекта замедления можно записать цикл в следующем виде:<br>
                                    <code>
                                        for (var i = 0, imax = arr.length, i < imax; ++i) {<br>
                                        ... тело цикла<br>
                                        }<br>
                                    </code>
                                </p>
                                <p class="text">
                                    Объявленная в цикле переменная i будет доступна и после цикла. После завершения всех итераций
                                    она будет равна своему последнему значению и это немного усложнит нам жизнь в будущем.
                                </p>
                                <p class="text">
                                    В цикле может быть несколько приращений, которые будут срабатывать при каждом прохождении цикла.
                                    Например:<br>
                                    <code>
                                        for (i = 0, j = 0; j < 10; i++<b>,</b> j += 2) {<br>
                                        ... тело цикла<br>
                                        }<br>
                                    </code>
                                </p>
                                <p class="text">
                                    Из выражения в скобках после <code>for</code> можно убрать любую часть, например:<br>
                                    <code>
                                        var i = 0;<br>
                                        for (<b>;</b> i < 10<b>;</b> ++i) {<br>
                                        console.log('Hello #' + i);<br>
                                        }<br>
                                        ... <br>
                                    </code>
                                </p>
                                <p class="text">
                                    Второй вариант (альтернатива цикла <code>while(condition)...</code>):<br>
                                    <code>
                                        var i = 0;<br>
                                        for (<b>;</b> i < 10<b>;</b>) {<br>
                                        console.log('Hello #' + i);<br>
                                        i++;<br>
                                        }<br>
                                        ... <br>
                                    </code>
                                </p>
                                <p class="text">
                                    Третий вариант (бесконечный цикл):<br>
                                    <code>
                                        for (<b>;;</b>) {<br>
                                        console.log('Hello #' + i);<br>
                                        i++;<br>
                                        }<br>
                                        ... <br>
                                    </code>
                                </p>
                                <p class="text">
                                    Точки с запятой внутри скобок должны присутствовать всегда!<br>
                                </p>
                            </section>
                            <section>
                                <a id="ch07.06"></a>
                                <h3>Цикл с предусловием (<code>while(condition) {...}</code>)</h3>
                                <p class="text">
                                    Синтаксис цикла с предусловием следующий:<br>
                                    <code>
                                        while(condition) {<br>
                                        ... тело цикла<br>
                                        }<br>
                                        ...<br>
                                    </code>
                                </p>
                                <p class="text">
                                    Цикл с предусловием стартует, если <code>condition == true</code>. Итерации будут повторяться до
                                    тех пор пока <code>condition</code> не изменится с <code>true</code> на <code>false</code>.
                                    В качестве <code>condition</code> обычно используются условия вида
                                    <code>someVar <= someValue</code>.
                                    Цикл вида:<br>
                                    <code>
                                        while (true) {<br>
                                        ... тело цикла<br>
                                        }<br>
                                        ...<br>
                                    </code>
                                    будет выполняться вечно, в этом случае страница со скриптом не загружается.
                                </p>
                                <p class="text">
                                    Во избежание подобных ситуаций в теле цикла необходимо предусматривать механизм, позволяющий
                                    переключить <code>condition</code> с <code>true</code> на <code>false</code>, чтобы произошел
                                    выход из цикла.
                                </p>
                                <p class="text">
                                    <code>condition</code> не обязательно должно быть логическим значением. Например верной будет
                                    запись <code>var i = 3; ... while(i) {... i--}</code>. В этом случае благодаря декременту
                                    переменная i через несколько итераций станет равной 0, а 0 интерпретируется как false, что
                                    приведет к выходу из цикла.
                                </p>
                                <p class="text">
                                    Следует иметь ввиду, что в случае, когда начальное значение <code>condition == false</code>
                                    цикл не выполнится ни разу, выполнение скрипта продолжится с выражения, следующего после
                                    цикла.
                                </p>
                            </section>
                            <section>
                                <a id="ch07.07"></a>
                                <h3>Цикл с постусловием (<code>do {...} while (condition)</code>)</h3>
                                <p class="text">
                                    Другая разновидность цикла позволяет выполнить код тела цикла, а после этого проверить
                                    выполнение условия. Это удобно в тех случаях, когда необходимо, чтобы тело цикло выполнилось
                                    хотя бы один раз. Синтаксис:<br>
                                    <code>
                                        do {<br>
                                        ... тело цикла<br>
                                        } while (condition);<br>
                                        ... <br>
                                    </code>
                                </p>
                                <p class="text">
                                    Обратите внимание на символ &quot;;&quot; после <code>&quot;} while (condition)&quot;</code>.
                                </p>
                            </section>
                            <section>
                                <a id="ch07.08"></a>
                                <h3>Прерывание и перезапуск циклов</h3>
                                <p class="text">
                                    Бывают ситуации, когда необходимо прервать выполнение цикла до момента выполнения условия или
                                    до завершения выполнения всех итераций. Это можно сделать с помощью директивы <code>break</code>.
                                    Пример:<br>
                                    <code>
                                        while (true) {<br>
                                        var userName = prompt(&quot;Login&quot;, &quot;&quot;);<br>
                                        if (!userName) break;<br>
                                        }<br>
                                        ...
                                    </code>
                                </p>
                                <p class="text">
                                    В данном примере осуществляется выход из цикла в том случае, если посетитель не указал свой
                                    логин.
                                </p>
                                <p class="text">
                                    Иногда для ускорения процесса необходимо досрочно завершить выполнение тела цикла на данной
                                    итерации (например, если мы знаем, что на данной итерации мы точно не получим искомый
                                    результат) и перейти к следующей итерации. Для этого служит директива <code>continue</code>.
                                </p>
                                <p class="text">
                                    Синтаксис:<br>
                                    <code>
                                        while(condition1) {<br>
                                        ... doSomeThing();<br>
                                        if (condidion2) continue;<br>
                                        ... doSomeThingElse();<br>
                                        }<br>
                                        ... <br>
                                    </code>
                                </p>
                                <p class="text">
                                    Как описано выше, чаще всего директивы <code>break/continue</code> используются в условных
                                    выражениях. А можно ли использовать для краткости не условные выражения, а условный оператор
                                    <code>(condition) ? exp #1 : exp #2;</code>?
                                </p>
                                <p class="text">
                                    Правильный ответ <strong>нет</strong>. Дело в том, что условный оператор <em>возвращает
                                    значение</em>, а директивы <code>break</code> и <code>continue</code> <em>не возвращают
                                    значение</em>. В условном операторе справа от символа &quot;?&quot; могут стоять только
                                    выражения, возвращающие значения или же сами значения.
                                </p>
                                <p class="text">
                                    Иногда циклы бывают вложенными, а нам нужно, при выполнении определенного условия выйти из
                                    всех циклов. Чтобы предусмотреть такую возможность можно поставить перед требуемым циклом метку
                                    вида <code>marker:</code> или <code>outer:</code> или <code>someElse:</code>. Имя метки должно
                                    быть уникальным. Ставится метка перед циклом вот так:<br>
                                    <code>marker: for (;;) ...</code><br>
                                    или так:<br>
                                    <code>
                                        marker:<br>
                                        for (;;) {...}<br>
                                    </code>
                                </p>
                                <p class="text">
                                    Дирректива <code>break marker</code> позволит выйти из ближайшего внешнего цикла с меткой
                                    <code>marker</code>. Выполнение скрипта продолжится после цикла.
                                </p>
                                <p class="text">
                                    Дирректива <code>continue marker</code> позволит перейти на следующую итерацию помеченного
                                    цикла.
                                </p>
                            </section>
                        </section>
                    </article>
                    <aside class="col-sm-12 col-md-4 col-lg-3">
                        <div class="row">
                            <div class="col-sm-6 col-md-12">
                                <!-- Content -->
                                <nav id="contents">
                                    <ul class="menu">
                                        <li><a href="#ch01">Начинаем</a></li>
                                        <li><a href="#ch02">Типы данных</a></li>
                                        <li><a href="#ch03">Переменные</a></li>
                                        <li><a href="#ch04">Операторы</a></li>
                                        <li><a href="#ch05">Приоритет операторов</a>
                                        <li><a href="#ch06">Преобразования типов</a></li>
                                        <li class="menu-list">
                                            <a href="#ch07">Сложные выражения</a>
                                            <ul class="menu-drop">
                                                <li><a href="#ch07.01">Блоки</a></li>
                                                <li><a href="#ch07.02">Условные выражения</a></li>
                                                <li><a href="#ch07.03">Условый оператор</a></li>
                                                <li><a href="#ch07.04">Выражение выбора</a></li>
                                                <li><a href="#ch07.05">Цикл со счетчиком</a></li>
                                                <li><a href="#ch07.06">Цикл с предусловием</a></li>
                                                <li><a href="#ch07.07">Цикл с постусловием</a></li>
                                                <li><a href="#ch07.08">Прерывание и перезапуск циклов</a></li>
                                            </ul>
                                        </li>
                                        <li class="menu-list">
                                            <a href="#ch08">Структуры данных</a>
                                            <ul class="menu-drop">
                                                <li><a href="#ch08.01">Понятие об объектах.</a></li>
                                                <li><a href="#ch08.02">Понятие массива</a></li>
                                                <li><a href="#ch08.03">Ассоциативные массивы</a></li>
                                                <li><a href="#ch08.04">Массивы с числовыми индексами</a></li>
                                                <li><a href="#ch08.05">Дата и время</a></li>
                                            </ul>
                                        </li>
                                        <li class="menu-list">
                                            <a href="#ch09">Функции.</a>
                                            <ul class="menu-drop">
                                                <li><a href="#ch09.01">Объявление функций</a></li>
                                                <li><a href="#ch09.02">Понятие о замыканиях</a></li>
                                                <li><a href="#ch09.03">Вызов функций</a></li>
                                                <li><a href="#ch09.04">Функциональные выражения</a></li>
                                                <li><a href="#ch09.05">Рекурсия, стек</a></li>
                                                <li><a href="#ch09.06">Именованные функциональные выражения</a></li>
                                                <li><a href="#ch09.07">Передача по ссылке</a></li>
                                                <li><a href="#ch09.08">Понятие о методах и свойствах объектов</a></li>
                                                <li><a href="#ch09.09">Методы чисел, строк, массивов, функций</a></li>
                                                <li><a href="#ch09.10">Перебор свойств объектов</a></li>
                                                <li><a href="#ch09.11">Массивы: перебирающие методы</a></li>
                                                <li><a href="#ch09.12">Псевдомассив аргументов &quot;arguments&quot;</a>
                                                </li>
                                                <li><a href="#ch09.13">Дата и время. Методы.</a></li>
                                            </ul>
                                        </li>
                                        <li><a href="#ch0$">Часть 8</a></li>
                                        <li><a href="#ch0$">Часть 9</a></li>
                                        <li><a href="#ch0$">Часть 10</a></li>
                                    </ul>
                                </nav>
                            </div>
                        </div>
                    </aside>
                </div>
            </div>
        </main>
        <footer>
            <div class="container">
                <div class="row">
                    <!-- Content -->
                </div>
            </div>
        </footer>
        <script type='text/javascript'>hljs.initHighlightingOnLoad();</script>
    </body>
</html>